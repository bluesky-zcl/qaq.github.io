
---
export_on_save:
 html: true
---

输入一个数m，输出数组中下标1~m的前缀和
对某个指定下标的数进行值的修改
$寻常方法的时间复杂度为O(n^2),效率低下$
那么我们可不可以对它进行优化？
当然可以啦。我们用数组A来记录初始值,在开一个辅助数组C。如图
![image.png](https://i.loli.net/2020/07/14/HphbesYfUCy9mVW.png)
C1 = A1
C2 = C1 + A2 = A1 + A2
C3 = A3
C4 = C2 + C3 + A4 = A1 + A2 + A3 + A4
C5 = A5
C6 = C5 + A6 = A5 + A6
C7 = A7
C8 = C4 + C6 + C7 + A8 = A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8

嗯我们先假设数组C以可用(如何处理在下面介绍)，我们来康康怎么求前m个数的前缀和吧
这里有种极为巧妙的方法：
吧m转换为二进制，不断把最后一个1改为0，所有以此为下标的c的和就是m的前缀和
例如m=7 
第一次,得到0111=7,
第二次,得到0110=6,
第三次,得到0100=4
最后得到0000(结束)
$即sum_m=c_4+c_6+c7$
那这玩意又怎么求呢？
lowbit(int m),这是一个函数,它的作用是求出m的二进制的末尾1的位置，则m=m-lowbit(m)表示不断把m的末尾的1进行减一操作。那lowbit究竟长啥样呢？
```
int lowbit(int m){
    return m&(-m);
}
```
嗯？惊不惊喜意不意外？就这么短
随便贴下求前缀和的代码
```
int sum(int m){
    int ans=0;
    while(m > 0){
        ans+=C[m];
        m-=lowbit(m);
    }
    return ans;
}
```
好的下面我们来介绍如何构造c.
$我们发现:c[i]=a[i-2^k+1]+a[i-2^k+2]+...+a[i]$
//k是i二进制中从最低位到高位连续0的个数,如i=8时k=3
$不难得出2^k就是lowbit(i)$
$如果我们更新a[i]的值那么就会影响到所有包含a[i]的位置,那哪些位置包含了a[i]呢$
$a[i]包含于c[i],c[i+2^k],c[(i+2^{k_i})+2^{k_{i+2^{k_i}}}]...$
```
void updata(int i,int k){    //在i位置加上k
    while(i<=n){
        c[i]+=k;
        i+=lowbit(i);
    }
}
```
好了恭喜你已经学会树状数组了,下面贴个完整代码就结束了
LGP3374
```
#include <cstdio>
#include <iostream>
using namespace std;
int n,m;
int c[500010];
int lowbit(int m){
    return m &(-m);
}
int sum(int m){
    int ans=0;
    while(m>0){
        ans+=c[m];m-=lowbit(m);
    }
    return ans;
}
void update(int i,int k){
    while(i<=n){
        c[i]+=k;i+=lowbit(i);
    }
}
int main(){
    scanf("%d%d",&n,&m);
    int i;
    int t;
    for(i=1;i<=n;i++){
        scanf("%d",&t);update(i,t);
    }
    int x,y,z;
    for(i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&z);
        if(x==1) update(y,z);
        if(x==2) printf("%d\n",sum(z)-sum(y-1));
    }
    return 0;
}

```